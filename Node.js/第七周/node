QQ:1282347298

TEL:13041086186

1.安装node和在WebStorm中配置Node代码提示包


2.扫盲 => 常用的DOS命令
 WIN键 + R键  -> 运行窗口 -》 输入cmd打开DOS命令窗口
 1） 查看本机电脑的IP地址  ：ipconfig
     IPv4地址 ：192.168.0.21  （局域网内的IP地址）
     子网掩码 ：255.255.255.0
     默认网关：192.168.0.1
     如果大家连接的是同一个网络，说明大家是在同一个局域网中，子网掩码和默认网管室相同的，这样的话大家就可以进行内部局域网共享了（可应用于移动端开发手机调试）

2）查看自己电脑的MAC地址（电脑连接网络后会生成一个全世界唯一的编码）
    物理地址：30-65-EC-18-CD-BB
    输入 ：ipconfig -all

3）cls  清屏

4） exit  退出DOS窗口

5）Ctrl + C  结束当前正在运行的操作

6) 查看自己当前的网络   ping www.baidu.com   (-t)多次
    延迟时间越短网络越快

7）打开DOC窗口的时候，默认进入的是 C:\Users\8  磁盘目录下
    如果使用DOC命令创建文件的话，也是默认创建在该文件下

    D：
    不管当前在那个磁盘内，想进入到D盘目录（进入某一个磁盘）
    cd 20161007  进人到当前目录文件夹下

    cd /  回到根目录
    cd ./ 回到当前目录
    cd ../  回到上一级目录

    dir 查看当前文件下有哪些文件

   如果我们像在指定的文件夹下操作DOC命令，除了以上操作外，还有一个简单的方法，直接找到要操作的文件目录，Shift+鼠标右键，直接打开命令窗口

    8）进人到指定的文件目录下、我们我们可以使用DOS完成I/O操作（所谓的I/O操作，就是对当前文件的增删改查）
    mkdir aaa  在当前目录下新建一个叫做ａａａ的文件夹

    del 11.txt   删除文件夹下的指定文件
    rmdir 在当前目录中删除aaa这个文件夹（前提是这个文件夹是空的）

    copy con xxx.txt(后缀名自己随便)  ==> 在出现的新一行中编辑自己想要写入的内容，编辑完成后想要保存退出：Ctrl + Z  ，完成后按下Enter完成

3) 面试题：当我们在浏览器的地址栏中输入了一个网址 （http：//www.baidu.com）当看到网站的内容;之间都经历了哪些事件
       1 首先到DNS服务器上通过域名找到服务器对应的外网IP
       2 通过外网IP找到对应的服务器
       3 通过端口号找到对应的服务和对应的文件目录
       4 在通过请求的文件目录名称，找到对应的资源文件

       “以上为请求阶段”

       5 把找到得资源文件（index.html）中的  源代码  ，返回给客户端的浏览器

      “response相应阶段”

       6 客户端的浏览器把获取到的源代码解析渲染成为对应的页面

       “Request + Response = 客户端和服务器端的交互模型”


    客户端：用户自己的电脑（电脑上的浏览器）
    服务器端：我们访问网站所对应的服务器

    开放分享，搭建自己的个人博客（从现在开始就可以把自己平时总结和学习的知识整理成相关的文档，后期博客创建完成后，可以把自己的文档都发布到博客上）


    买一台服务器，会有一个外网IP 112.125.158.152

    买一个域名 ：www.zhufengpeixun.com

    把自己的项目代码上传到服务器    FTP上传

    在当前的服务器上发布一个服务（ 用来管理项目资源文件），一台服务器上可能会发布好几个服务，如何区分这些服务呢？我们给每一个服务监听一个端口号，服务和服务之间的端口号是不能够重复的    假设我们当期的服务端口号是80；
    -> 以后80这个服务就会对服务器下的某个磁盘下的文件负责了

    域名解析或者是DNS解析 ：把我们买的域名和服务器的外网IP 关联在一起，会在DNS服务器上产生一条记录
    100234  www.zhufengpeixun.com   112.125.158.152

    我们知道的所有的网站，域名都会在自己服务器的外网IP地址，在DNS服务器上储存一条记录


    在谷歌浏览器的控制台可以看到当前客户端和服务器端交互的所有交互的信息

    通过上述的的请求交互操作，客户端第一次把index.html中的源代码获取到了，客户端的浏览器开始从上到下，从左到右依次渲染和解析，在渲染的过程中遇到 link 、img、script...等标签，还需要重新的向服务器发送请求（重复到DNS找外网IP -> 找服务器 -> 找服务 -> 返回源代码。。。这样的过程），把需要的Css、图片、js获取到、在进行渲染....经历了N多次请求后，我们的页面才能够完整

    如果请求的次数比较多的话，页面打开的速度会变慢，如果要进行优化的话，我们需要“减少HTTP请求的次数”


    URL:统一资源定位符
    URI:统一资源标示符    URL+URN = URI
    URN:统一资源名称
    一个URL完整的地址其实是包含很多部分的：
        http://www.zhufengfeixun.com:/index.html?name=zf&ag=8#video

    【传输协议】
        客户端和服务器端内容传输的搬运工
        HTTP:超文本传输协议（最常用的）
        HTTPS:比THHP更加安全的超文本传输协议 HTTP SSL
        FTP:文件资源传输协议，一般应用于把本地的资源文件上传到服务器上（大型文件传输）
        ...

    【域名 Domain Name】
        一级域名  www.qq.com
        二级域名  sports.qq.com
        三级域名  kbs.sports.qq.com
        ...

   【端口号：用一个数字来区分当前服务器上的不同服务的】
        一台服务器上，不同服务之间的端口号是不能重复的，端口号的取值范围是：0-65535之间

        在URL地址中如果我们没有指定端口号（没有写数字），不同的传输协议，到服务器上找的服务（默认端口号）也是不同的

        http://v.qq.com/   => HTTP传输协议默认找80端口的服务
        https://www.baidu.com/   => HTTPS传输协议默认找的是443端口的服务
        ftp://xxx.xxx   =>  FTP  传输协议默认找的是21端口的服务

    【客户端请求资源 文件的目录和名称】
        当前：/index.html  请求的是当前项目根目录下面的index.html
        /css/index.css     请求当前项目根目录下Css文件夹中的index.css文件

     在真实项目中没有看到具体的资源文件
     ->http://www.zhufengpeixun.com/html12peixun/这样没有写具体的请求资源名称的，可能存在两种情况：
            1）我们请求的资源文件是服务默认的请求文件（默认的文件可能是index.html或者default.html）,不写的话，服务器端会把默认的文件中的内容返回给客户端
            2）我们当前看到的请求URL是伪造的（伪URL或者URL重写），这样做的话其实是在骗搜索引擎的爬虫，让其能够多收录一些内容，有助于SEO推广，列如：http://www.szyc.com/zydhy/  真实请求的地址：http://www.szyc.com/zydhy/index.html


     【问号传参】
     此处：？name = zf&ag = 8;
     作用：
        ->客户端可以把一些信息传递给服务器，使用的传递方式有好几种方式，问号传参就是一种，这里出现的name = zf & age = 8 其实就是客户端本次传递给服务器端的内容，服务器端可以根据项目的需求，接受到传递的信息，从而给客户端呢返回想要的结果

            -> 前端开发的部分时候，也会获取到URL地址栏中的问号参数值，从而做一些处理；

            我们从列表进入到的详细页面其实是一个页面，但是页面中展示的却是不同的信息，主要是根据URL中  问号传参的不一样来判断该展示哪个信息
      【HASH哈希值】
            此处：#video
            作用：
             -> 和问号传参一样，客户端也可以通过#HASH把一些内容传递给服务器端
             -> 最主要的作用是当前页面的锚点定位（直接的定位到当前页面中的元素的ID为video这个区域）
             -> 作为前端路由的判断依据（C模块）


   扫盲
     W3C：万维网联盟  一个非盈利性机构，主要是用来制定IT编程语言的规范和标准的
     我们开发者按照标准和规范去开发代码
     浏览器开发商按照标准和规范去解析我们开发的代码，把我们的代码渲染成一个WEB页面

     浏览器中有自己渲染解析代码的内核（渲染引擎）
        谷歌Chrome、Safari、V8内核、webkit内核
        火狐FirFox：Gecko
        IE:Trident
        ...
        每个浏览器渲染解析的内核不一样，解析的机制也是不一样的，所以导致了兼容性问题

        我们写的代码只有放在浏览器的内核中进行解析，才会起起到应有的作用，否则就是一堆破代码，所以我们之前就是这样定义JS的：一们轻量级的客户端（浏览器）脚本编程语言；

        从现在开始JS有了全新的解释：JS是一门编程语言，可以实现全栈开发的编程语言，和我们之前了解的PHP、C#、.NET(dot net)、JAVA...语言是相同的
        目前浏览器可以解析渲染我们的JS代码，我们也可以用HODE来解析渲染我们的JS代码



NODE
    NODE不是我们想象中的后台语言，他不是你们语言，他是一个和浏览器类似的工具或者平台，在NODE平台中，可以把我们写的JS代码解析出来，而且NODE和谷歌浏览器一样都是采用V8引擎渲染解析的

     以后只要在服务器上安装了NODE,就可以在服务器上用JS代码编写一些服务端需要处理的事情和操作，最后把这些js在服务上的NODE 环境下执行即可  ==> js也可以写后台程序了

如何在NODE 环境下执行JS
    安装完成NODE会把NODE的命令集成到DOS中，以后再DOS窗口中也可以执行NODE命令

     1）首先找到要执行的JS文件所在的目录，在这个目录当中打开DOS命令窗口（Shift+鼠标右键+在此处打开命名窗口），在NODE窗口中执行NODE命令：node xxx.js  -> 把JS代码在NODE 环境中执行


     2）如果使用的是WB这个 IDE,我们直接的在需要执行的JS代码空白处，鼠标右键，Run xxx.js即可  ->WB中继承了NODE的执行，上述这样的操作，就是由WB调取的NODE的执行文件，把需要执行的JS执行了


NODE的优势（相当于传统的后台语言）
  ->快，因为他是给予V8引擎渲染JS的
  ->基于单线程的异步操作
  ->它提供了无阻塞的I/O操作（文件的增删改查）


  JS在客户端运行的时候，浏览器为了保证用户的安全，是不允许JS操作客户端的文件的，也就是JS在客户端运行不能进行I/O操作（有一个东西浏览器提供<input type="file"/>）

  JS运行在服务端的NODE环境中，由于操作的是自己的服务器，不可能随意进行破坏，所以NODE 环境下提供了JS对于服务器的I/O操作

  在NODE 环境下也提供了供JS调取的属性和方法
    1）内置模块

    2）自定义模块
      在NODE 环境下，创建的每一个JS文件都是一个独立的模块，互相之间不冲突

      想在B模块中调用A模块里面的fn函数:

      //导入A模块
      var a = require('A')
      //A模块导出
      //module NODE天生提供的对象，储存了一些模块操作的属性和方法；
      module.exports = {
            fn:fn
      }

    3）第三方模块（第三方模块的管理统一使用NPM命令）
        1 下载  ：https://www.npmjs.com/(第三方模块都在这个网站管理者)
                列如：我们想使用LESS模块   npm install less 在当前项目目录下下载LESS模块（执行 lessc -v  查看是否安装成功）
                npm install less -g 在全局下下载LESS模块（-global）
                npm uninstall less / npm uninstall less -g  卸载第三方模块

        2 引入
       var less = require("less");//导入
        3 使用
        less.render();  //导入进来就可以执行LESS下面的render方法了



       思考题 ： 我有三个模块A，B,C,A中有一个sum的方法实现任意数求和，B中有一个叫做avg的方法实现求平均数（先求和然后除以个数算出平均数->B中就需要调取A中的sum）,C种调取B中的avg方法，传递一堆数，实现求平均数
       视频  133-134



二 NODE中的内置模块
     1 HTTP   创建服务、监听端口、接受客户请求、给客户端返回对应的内容。。。

     2 URL    提供了一些方法，用来解析URL中的每一部分信息的

     3 FS     提供了一些方法供我们进行I/O操作

              fs.readFileSync([pathname]，‘UTF - 8’);同步读取文件中的内容、
              fs.readFile:异步读取文件中的内容
              ->[pathname]:要读取内容的编码格式，我们用“UTF - 8”
              读取出来的内容都是字符串

              fs.writeFileSync([pathname],[content],[encode]):同步向一个文件中写入内容
                ->[content]:我需要写入的内容，也必须是字符串格式的数据
                这个写入方式是覆盖式写入
              sync:同步
              async:异步

三.MIME类型
  每一个资源文件（HTML/CSS/JS/...）都有自己对应的数据类型，这个类型就叫做MIME类型；
  HTML -> text/html
  CSS ->text/css
  JS ->text/javascript



四 .AJAX
    1 什么是AJAX和AJAX是干什么的？
    async javascript and xml
    异步的JS: 指的是页面中某一个区域的局部刷新（有人把AJAX的作用称之为：实现页面的局部刷新）
    XML    ：可扩展的标记语言（HTML中的标签都是W3C规范的，但是XML中的标签基本上就是自己定义的），我们平时可能使用XML来存储数据，这样的数据结构化要强...
    HTML：超文本标记语言
    XHTML:更加严谨的HTML(我们现在用的其实就是XHTML);

    2. AJAX是干什么的？
    客户端的浏览器也可以向服务器端发送请求，把所需要的资源文件中的源代码获取到，这些请求是不需要使用AJAX的，我们平时使用AJAX也是项服务器端发送请求，但是获取到的内容一般都是（JSON格式的数据 -> JSON格式的字符串），客户端拿到数据后把数据展示到页面上即可

    使用AJAX：
        var xhr = new XMLHttpRequest ;//创建一个AJAX的的实例（AJAX的对象）

        //->xhr.open:打开一个请求的URL，并且配置一些基本的参数
        xhr.open([HTTP METHOD],[REQUEST URL],[SYNC/ASTNC],[USER NAME],[USER PASS]);
                    方式          地址            同异步
        xhr.onreadystatechange = function(){//onreadystatechange:AJAX状态发生改变的时候就会触发这个事件，因此把后面的函数执行
            //->xhr.readystate :AJAX状态
            //->xhr.status :服务器响应的状态码
            if(xhr.readystate === 4 && /^2\d{2}$/.test(xhr.status)){
                ->xhr.responseText:获取服务器返回的内容（响应主体中的内容）
            }
        }

        -> 发送AJAX请求（此时AJAX请求这件事情就算是开始了，直到服务器把我需要的内容给我才算结束）
        xhr.send([POST DATA])

       【HTTP METHOD】ajax 请求方式
            在前后端交互模型中（客户端和服务器端的交互模型），客户端既可以给服务器发送请求，也可以在发送请求的时候把一些内容传递给服务器，服务器接收到请求后，以及拿到客户端传递给进来的内容后，会把需要的东西给客户端返回。
        [get系列]
            get:（获取） 一般应用于给服务器端的少，从服务器端获取的多
            delete:（删除）在服务器上删除一个文件
            head:（头）只获取服务器返回的响应头信息，响应主体信息不获取

            客户端如何把信息传递给服务器：
                ->问号传参：在请求的URL地址后面加问号的方式
                ->通过请求头把信息传递给服务器
                ->通过请求主体传递给服务器
            服务器端把信息返回给客户端：
                -》通过响应头
                -》通过响应主体

        [post系列]
           post:（推送）给的多，拿得少
           put:（放）在服务器上放一个文件（传文件）

        get pk post:
            get系列传递给服务器的方式是采用问号传参的方式
            xhr.open("get",'getAll?name = zf&age=8');
            xhr.send(null)

            post系列传递给服务器内容的方式采用请求主体
                xhr.open('post','/getAll');
                xhr.send('{"name":"zf","age":"8"}')

         1 传递内容大小问题
            get 请求使用的是问号传参方式。post使用的是请求主题的方式；get请求传递给服务器的内容比较少（因为：如果传递的内容比较多，那么在请求URL后面拼接的内容就要很多，每个浏览器对于URL长度都有限制，谷歌限制8KB,火狐限制7KB，IE限制2KB，超过限定的部分会被浏览器截取，这样传给服务器的内容就不会不完整了）
            post是放在请求主体中传递给服务器的，理论上没大小限制的（实际项目中为了保证传输的速度，我们会限制大小）

         2 缓存问题
            get请求容易出现缓存（这个缓存我们一般不要，因为是浏览器和服务器之间私下做的猫腻，我们不可控；如果需要的话我们就需要使用特殊的技术来处理才可以）
            post请求中是不会出现缓存的

            解决缓存：保证每一次请求的URL地址和问号传参不完全一制，这样就不会出现缓存了；
            (在请求的URL后面加上随机数)
                xhr.open("get","/getMoney?_="+Math.random)

         3 安全问题
            get请求不安全，post相对来说比较安全

    以上内容都是市场上大家开发的时候约定俗称的规范

        【sync/asyns】
           sync:同步；
           async:异步（第三个参数不写默认是异步）


        [USER NAME],[USER PASS])
        基本上这两个参数没用，两个参数的意思是向服务器发送请求的时候提供可以进入服务器的用户名和密码


        xhr.readystate:AJAX状态
           0  UNSENT  未发送  开始new XMLHttpRequest成功后状态就已经是0
           1  OPENED  已打开  已经执行了xhr.open
           2  HEADERS_RECEIVED  AJAX已经发送，并且响应头信息已经接受
           3  LOADING  响应主体内容正在加载
           4  DONE   相应主体已经接收完成

        在响应头当中有一些信息还是比较有用的：Data(储存的是服务器时间，服务器即将把头部信息返回的时候对应的时间)
            发请求 -> 服务器接受请求 -> 服务器返回头部信息（10:00） -> 客户端接收到头部信息（此时已经10:01，但是我们从响应头中获取到的时间是10:00，这样就导致了一分钟的误差） -> 服务器继续返回主体信息 -> 客户端接受到主体信息（请求结束，此时已经10:05，如果这里还是获取响应头的信息，拿到的事件还是10:00，这样误差更大）


            var xhr = new XMLHttpRequest;
            xhr.open("head","/getServerTime?_="+Math.random(),true);
            xhr.onreadystatechange = function(){
                if(/^2\d{2}$/.test(xhr.status)){
                    if(xhr.readystate ===2){
                        //->获取响应头信息，获取服务器的时间：获取到的时间是一个格林尼治时间（GMT+0000） 北京时间是（GMT-0800)
                        var serverTimer = xhr.getResponseHead("date");
                        serverTimer = new Date(serverTimer);//把一个指定时间格式的字符串转换为标准的北京时间
                    }
                }
                }

            xhr.send(null);


Http 报文
    客户端传递给服务器的内容和服务器返回给客户端的内容统称为HTOO报文
    -> 起始行：请求的起始行。响应的起始行

    ->首部（头）：通用头、请求头、响应头、自定义请求头、自定义响应头

    ->主体：请求主体、相应主体

    客户端传递给服务器的内容（请求报文）：起始行、首部、主体
    服务器返回给客户端的内容：（响应报文）：起始行，首部、主体；

    谷歌浏览器：F12 -> Network -> 查看所有的客户端和服务器端的交互信息

    客户端把内容传递给服务器的方式：
        -> 问号传参：他和报文没有关系，我们是把传给服务器的内容放在URL的末尾了，服务器端也是先获取URL，然后把问号传参的值解析出来
        -> 把需要传递的内容放在请求头或者请求主体中传递给服务器
            对于请求头或者请求主体，服务器端获取请求头和请求主体中的内容；
            在真实性项目中，我们想把一堆内容传递给服务器，肯定用请求主体的方式，但是如果想把一些基础的标示（cookie）传递给服务器，我们一般都请求头；

    服务器端把内容返回给客户端的方式：
        -》把需要返回的内容放在响应头或者相应主体中返回
            服务器段设置响应头或者相应主体，客户端返回响应头或者响应主体中的内容
            在真实项目中，服务器返回给客户端的内容一般是通过相应主体来返回的（响应头中的信息一般都是默认返回的，不需要自己设置；但是响应头中有一些内容还是很有用的：服务器的时间、内容的MIME类型：Content-type）

    HTTP响应的网络状态码（网络状态码）：xhr.status
    200：OK  成功（以2开头的都算是成功）

    301：永久转移（永久重定向）
    302： 临时重定向  服务器的负载均衡
    304：设置缓存（读取的是缓存数据） 项目中我们经常会给css/js/图片做304缓存，来优化页面的性能（304缓存的设置需要服务器做配合，这种方式的缓存是我们用技术可控的）=>三开头也算成功，只不过是中间经历了一些处理

    400：传递给服务器的请求参数出现错误
    401：没有访问的权限
    404：请求的地址是错误的
    =>四开头的是失败，一般都是客户端的原因

    500：未知的服务器错误
    503：服务器超负荷
    =》五开头的是失败，一般都是服务器的原因


    AJAX这个请求数据的任务、从什么时候开始，到什么时候结束！
    从执行了xhr.send()后请求数据这件事情就开始了，到xhr.readystate === 4 的时候说明这件事情就已经结束了


通过WB预览页面，地址是http://localhost:63342/,说明WB会默认的创建一个服务（63342）；客户端请求的是资源文件，63342这个服务会把资源文件中的源代码给客户端返回


真实项目的开发流程
    产品设计师：把老大的IDEA转化为真实的产品，分析构建产品的形态（定需求）
    UI设计师（美工）：根据陈品的需求设计图片（PSD格式的设计稿 PhotoShop skech设计稿）
    前端开发工程师:拿到UI的设计稿，使用HTML5+css3把页面的样式搭建出来
                =>把图片变成网页（100%还原）   需要我们会PhotoShop进行切图量尺寸等
                =>使用JS获取JQ等插件实现一些操作的效果
                =>从服务器端获取数据（AJAX/JSONP）  我们首先去找后台要请求数据的API接口地址，后台开发工程师否会给我们一个文档（API文档），在文档中描述了请求的地址，请求的方式，需要我们传给服务器什么和服务器返回给我们的数据长什么样...
                前端开发拿到API文档后不需要管后台是怎样实现的，我们只需要知道按照某一个地址，按照文档的要求把该给服务器的给他，把我们需要的获取到即可，该展示就展示，该提示就提示...
    后台开发工程师：
                =>具体的功能实现都是后台做的，列如：到底如何增加客户，修改客户，存到哪？（一般都是储存到数据库中）
                =>还需要给前端开发调取的功能接口
    测试工程师
            =>把做好的产品测试，测试BUG
    服务器运维工程师
            =>把项目部署到服务器上，可以让外部的用户访问到













