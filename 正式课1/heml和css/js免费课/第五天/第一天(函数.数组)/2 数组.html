<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
</body>
</html>
<script>
    /*
    *   length属性 ： 数组天生自带的属性，记录的是当前这个数组里有多少项
    *   length--: 可以把数组的最后一项删除
    *   length++: 从来不用，但是却可以在末尾添加一个undefined
    *   ary[ary.length] : 向数组的末尾添加一项
    * */
    // Array 数组
    var ary = ['a','b','c']; //声明一个数组  ES5
    //let ary = []; // ES6声明一个数组
    //console.dir(ary);
    //ary.length--;
    //ary.length++;
    ary[ary.length-1] = 'cc'; // ary[2] = 'cc';
    ary[ary.length] = 'dd'; // 向数组的末尾增加一项 => 就是一个赋值过程
    ary[7] = 'tt'; // 这种跳跃式添加中间缺少的项是用undefined补齐的
    console.dir(ary);

    /*
    *   如何记忆数组的方法：
    *       1 方法的作用(方法是干嘛的)
    *       2 方法的参数 (方法运行的时候需要的值或者变量)
    *       3 方法的返回值(方法执行完留下了什么)
    *       4 是否的改变原有数组(会不会破坏原有数组)
    * */

    //  增删改查

    // push
    // 1  向数组末尾添加项
    // 2 参数就是要增加的项
    // 3 返回值是数组的新长度
    // 4 原有数组改变(增加了项目)
    // ps: 如果在末尾增加多项那么就在参数位置用逗号隔开
    var ary = ['a','b','c'];
    var res = ary.push('d','e'); //我要把d添加到ary数组的末尾
    console.log(ary);
    console.log(res); //我查看push方法运行结束之后的结果

    // unshift
    // 1 向数组的开头增加项
    // 2 参数是要增加的数组项目，如果是多个用","隔开
    // 3 数组的新长度
    // 4 原有数组改变
    var ary = [1,2,3];
    var res = ary.unshift(-1,0);
    console.log(ary);
    console.log(res); // 查看返回值

    //pop
    // 1 删除数组的末尾项
    // 2 不用参数，就是删除最后一个
    // 3 返回值是删除的最后一项(可不是新长度)
    // 4 原有数组改变
    var ary = ['x','y','z'];
    var res = ary.pop();
    console.log(ary);
    console.log(res);

    //shift
    // 1 删除数组的开头项
    // 2 不用参数
    // 3 返回值是删除的第一项
    // 4 原有数组改变

    var ary = ['l','m','n'];
    var res = ary.shift();
    console.log(ary);
    console.log(res);

    //splice
    // 1 删除数组项可以指定具体的哪些项
    // 2 splice(n,m) 从索引n开始删除m个
    //   splice(n) 如果第二个参数没有写那么就是从n索引开始删除到末尾
    //   splice(0)  从第一项开始删一直到末尾
    //   splice(n,m,x,y) 从索引n开始删除m个，然后用x,y去顶替删除的位置,从第三个参数开始都是用来填补删除的项目位置的
    // pop => splice(ary.length-1,1); 从最后一项的索引开始删除1个
    // shift => splice(0,1) 从索引0开始删除1个
    // unshift => splice(0,0,'tianxi') 从索引0开始一个都不删，然后把'tianxi'字符串添加到第一个索引0的前面
    // push => splice(ary.length,0,'tianxi')
    // 3 返回值是删除的数组项目组合成新数组
    // 4 原有数组改变
    var ary = ['a','b','c','d'];
    //删除之后留下a和d
    //var res = ary.splice(1,2);
    //var res = ary.splice(1,0);
    //var res = ary.splice(0); //可以达到克隆数组的目的，但是利用却是返回值
    //var res = ary.splice(1,2,'zhufeng','peixun','tianxi');
    //var res = ary.splice(1,0,'tianxi'); //从索引1开始没有删除项，然后添加"tianxi"字符串，添加的位置是索引之前.
    //var res = ary.splice(0,0,'tianxi');
    var res = ary.splice(ary.length,0,'tianxi'); //模拟push由于splice的添加从操作是默认添加到前面的。所以模拟push需要把索引+1。也就是ary.length
    console.log(ary); //
    console.log(res); //
    //console.log(ary === res); // false

    //slice
    // 1 用来复制数组
    // 2  slice(n,m) 从索引n开始复制到索引m，但是不包含m(其实也就是复制到m-1)
    //    slice(n)   从索引n开始复制到末尾
    //    slice(0)   从开头复制到末尾  克隆数组
    //    slice()    从开头复制到末尾 克隆数组
    // 3 返回值是新复制的数组
    // 4 原有数组不改变

    var ary = ['a','b','c','d','e'];
    //要求复制['b','c','d']
    //var res = ary.slice(1,4);
    //var res = ary.slice(0);
    var res = ary.slice();
    console.log(ary);
    console.log(res);
    console.log(ary == res);

    //如何查看数组到底有多少个方法
    console.log(Array.prototype);
</script>