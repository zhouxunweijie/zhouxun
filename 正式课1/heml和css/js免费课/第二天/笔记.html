<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
复习：
1、数据类型：
基本数据类型：数字() 布尔 null undefined 字符串
引用数据类型：{
    函数：function
    对象：正则类（RegExp） 对象类（Object） 字符串类(String) 数组类(Array) 时间类(Date)...
}

2、数字数据类型
包括 正数 负数 小数 0 NaN
isNaN()判断是否是一个有效数字 是false  不是true
isNaN判断之前要进行数字的强制转化
Number()将其他数据类型强制转化为数字数据类型
非强制转化 从左到右依次查找 遇到第一个不是数字停止
parseInt()---只能识别整数
parseFloat()---可以识别一个小数点
parseFloat()和Number() 可以补零
NaN和NaN比较 false

******
isNaN的返回值 true/false
Number/parseFloat/parseInt返回值 数字/NaN
******

3、布尔数据类型
有两个值 true false
true--1
false--0

!    将其他数据类型转化为布尔再取反
!!   将其他数据类型转化为布尔再取反再取反
!! 和 Boolean()是一样的功能  就是将其他数据类型转化为布尔数据类型

判断“一个”值是否为真的规律：
0 NaN null undefined "" 为假 其余都为真

***
!/!!/Boolean()  布尔运算 --》 true/false

![]   !Boolean(val)
第一步是将[]转换为布尔值true
第二步取反!true--false

![]==[]
左侧：
第一步是将[]转换为布尔值true
第二步取反!true--false
第三步false--0
右侧：
1、[]--''
2、''--0
0==0--true

!([]==[])--true
***

4、一个值判断true/false的时候遵循：0 NaN null undefined ''为false 其余都为true
****
两个值进行判断的时候，遵循的原则（==）
== 是比较 会默认将等号两侧的数据类型进行转化，然后在比较
===是绝对比较  不会默认转化 等号两侧的值必须是同一数据类型
****
1、对象==对象  永远是false  [] {} /^$/
对象：正则类（RegExp） 对象类（Object） 字符串类(String) 数组类(Array) 时间类(Date)...

2、对象==字符串  对象转化为字符串  .toString()
[].toString()-->''  {}.toString()-->'[object Object]'
3、对象==布尔 都转化为数字  对象--字符串--数字  布尔--数字
4、对象==数字 对象--字符串--数字
5、数字==布尔 布尔--数字
6、数字==字符串  字符串--数字
7、字符串==布尔  字符串--数字  布尔--数字
8、null==undefined  true  null===undefined false
9、null、undefined和其他比较  永远是false
**************
只要对象要转化 第一步永远是将它转化为字符串
其余最终都转为数字
!就是布尔
**************

5、对象数据类型 object
两种创建方式
字面量创建  var obj={属性名1:属性值1,属性名2:属性值2...}
实例创建     var obj=new Object();
             var ary=new Array();

获取属性和属性值
对象名.属性名
对象名["属性名"]--如果属性名为数字，可以省略''，如果属性名为数字，只能用[]获取

修改和增加属性
对象名.属性名=新的属性值;
对象名.新的属性名=新的属性值;

删除属性
假删除：对象名.属性名=null;
真删除：delete 对象名.属性名;

6、判断
if else  用在js中所有的判断
if(条件1){
    条件一成立时执行的代码
}else{
    以上条件都不成立执行的代码
}
(条件1)--true/false

三元运算符（三目）  用在简单的if else判断上
条件?条件成立时执行的代码:条件不成立执行的代码;
条件?条件成立时执行的代码:void 0;

switch  用在不同值的不同操作
条件
===1
===2
===3
switch (条件){
    case 值1:
        条件===值1执行的js代码;
        break;
    case 值2:
        条件===值2执行的js代码;
        break;
    default :
        提上条件都不成立执行的js代码;
}
break--跳出判断/停止判断（当break前面的条件成立的时候，立刻停止判断）

if(![]==[]){
    console.log("1");
}else{
    console.log("2");
}
switch (![]){
    case []:
        console.log("1");
        break;
    default :
        console.log("2");
}

7、循环
for 用在已知循环范围的循环上  循环每一项
a、声明一个变量 给变量设置初始值
b、规定循环的范围
c、执行循环体中的代码 {循环体}
d、累加操作（自增操作） i++ i+=1 i=i+1
for(var i=0;i<9;i++){循环体}
{0-8} i=9
continue : 让当次循环体中的continue的代码不运行
break : 跳出整个循环

for in 用在遍历对象的循环上 {} []
for(var 变量 in 对象){
    变量代表的是对象中的属性名
}
在获取这个对象属性的时候，只能使用[]的形式，因为我们不确定对象中的属性名是否有数字

对象[变量]==>为什么[]中不用引号 因为再js中变量是不能有引号的，有引号的是字符串
对象[属性名] -- undefined

如果属性名是数字的情况，先按照数字大小进行遍历，在按照书写顺序遍历其他 属性

while循环 用在未知循环范围上
var i=0;
while(i<9){
    console.log(i);
    i++;
}
console.log(i);


检测数据类型(2分)

typeof  --> 返回值 首先是一个字符串 引号包住的内容才是这个值的数据类型
'数据类型'

[] {} //-->'object'
null-->'object'
typeof 的局限性  不能具体细分对象下面的具体的数据类型 [] {} //
true-->'boolean'
false-->'boolean'
数字-->'number'
函数-->'function'
undefined-->'undefined'
''--'string'

当typeof两个以上的时候 最终值就是 'string'

constructor

instanceof

Object.prototype.toString.call()

基本数据类型与引用数据类型的区别
基本数据类型是对值的操作，每一个对象的值都是自己的，所以操作的时候都是没有关系的

引用数据类型：
1、浏览器遇到引用数据类型就会开辟一个内存空间，将这个对象中的js代码块当做字符串存到这个空间中，自动生成一个十六进制的地址，将这个地址给到这个对象，也就是说这个对象中存的不是js代码块，而是一个地址而已

2、obj2=obj1的是，不是将obj1的代码给到这个obj2，而是将刚刚的地址给到obj2，那么也就是说obj1和obj2操作的是同一个内存空间

3、当改变其中一个对象的属性值或者新增或者删减的时候，都是操作这个空间的内容如，最终两个对象引用的这个空间就会被修改

用一句话总结：
基本数据类型是直接对值的操作
引用数据类型是对一个空间地址的操作


对象中的属性：
第一类 内置属性    对象天生自带的属性
第二类 自定义属性  人为定义的属性 存我们想存的值

+号遇到字符串 就会优先进行字符串拼接 然后是数学运算
"1"+i=1i   "1"+1+1=111
+号如果遇到的都是数字 那么会优先进行数学运算
1+1=2

onclick--鼠标点击事件
onmouseover--鼠标移入事件
onmouseout--鼠标移出事件

自定义属性：
1、放for循环后会得到一个最终值 当循环内有函数的时候，这个函数只有被调用的时候才会执行，那么当函数调用的时候，for循环早已结束，那么这个函数要获取到的循环中的变量，就是一个最终值
这个时候我们会用到自定义属性，将我们要得到的变量分别存给要操作对象上的属性里，当要使用这个值的时候，从这个属性中拿出来，属性分为内置属性和自定义属性，内置属性都是有自己作用的，我们不能随便篡改，所以我们可以自己给这个对象添加一个新的属性，用来存值

2、当前后操作同一属性的时候，后面的值会覆盖前面的值，那我们也需要前面值的时候，我们可以个这个对象增加一个新的属性，将我们需要的值存到这个里面

自定义属性就是将我们需要的值，存到this（这个对象）的属性里面，相当于一个容器，等到用的时候，再从这个容器中取出，只不过这个属性是我们自己定义的新的属性


选项卡思想：
点击哪个对象，就将特殊的类名给到哪个对象，我们需要先将所有要操作元素的类名去掉，给我们操作的那个元素添加上类名













</body>
</html>