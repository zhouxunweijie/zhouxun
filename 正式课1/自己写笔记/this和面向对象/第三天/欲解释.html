<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    /*
    * 欲解释（变量提升）=》变量提前声明，在代码执行之前就声明过了。在代码执行之前把带var和function的都会提前声明，var和function的区别：带var的会提前声明但是不会赋值，会默认一个undefined，而function会提前声明也会赋值，
    *
    *
    * 欲解释只看等号左边的，及时等号右边是一个实名函数，那么这个函数名也不会被欲解释
    *
    * 一般函数右边不写函数名
    *
    *
    * 2    in  运算符
    * 全局变量都属于window对象的属性
    *
    * 3 自运行函数是不会被欲解释的
    *
    * 4  return后面即使是一个实名函数也不会被欲解释
     *   return 后面如果是一个
     *   return  下面的函数即使无论是函数还是变量都是会被欲解释的
     *
     *
     *
     *   函数和变量重名的时候，在欲解释阶段
     *
      *
      *
      *   函数的执行过程，先开辟一个新的栈内存=》形成一个新的私有作用域，函数的形参相当于定义在函数体内的私有变量，
      *
      *      1  形参赋值  =》 如果实参是引用数据类型，是把实参所代表的引用地址赋值给形参一份
      *      2 欲解释函数体内带var和function的=》欲解释 只发生在当前作用域，也就是你正在执行的这个函数所产生的作用域
      *      3 代码执行
      *
      *
      *  私有和全局作用域
      *
      *    如果自己私有作用域没有这个变量，他就会去上一个作用域去找
      *
      *
      *
      *    内存释放
      *
      *    内存释放其实就是内存没有占用的时候，浏览器就会主动回收；
      *
      *    将变量等于null  那么浏览器就会主动将这个堆内存释放了
      *
      *    栈内存的释放
      *
      *      1  函数执行的时候（只有函数执行才有作用域），函数中的某一部分（引用数据类型）被函数外的变量或者对象的属性（对象不一定是{}可以任意一个引用类型），那么函数运行所产生的作用域就不会被释放，导致这个作用域内的私有变量也不会被释放=》上一次被修改的值，下次运算还是会拿到，而不是重新赋值
      *      ps 每次形成的私有作用域都是相对独立的，里面的私有变量也是独立的
      *
      *
     *内存不立即释放
     *
     *
    * */
function foo(){
    var i=98;
    return function(){
        console.log(++i)
    }
}
    foo()();
l1
</script>
</body>
</html>