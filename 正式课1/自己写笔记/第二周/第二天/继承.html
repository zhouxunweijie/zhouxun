<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    /*
    *   继承：子类继承父类的方法和属性
    *
    *
    * */
//    1  原型继承 ：子类的原型指向父类的实例     B.prototype = new A();
//                    子类的私有和公有方法都是子类的公有方法
//

    /*
    *    2      call继承  ：在子类的构造函数中执行 C。call（this）
     *                                             夫类。call（this）
     *                      把夫类的 私有办法变成子类的私有方法
    *
    *
    *    把C夫类中函数中的this修改成当前的this（当前实例），相当于C父级
    *
    * */

    /*
    * 3 冒冲对象继承：在子类的构造函数准中遍厉父级的一个实例，并且把所有便利出的属性和方法，分别添加给子类实例
    *                 如果在遍历数组的过程中不适用hasOw
    *
    *
    *
    *
    *
    *
    *
    *  4  组合继承  原型继承+call继承
    *       由于原型继承是把私有+公有全部都变成了子类的公有，call继承就是把私有变成私有。组合在一起就子类的公有方法中多了一套夫类的私有办法
    *
    *
    *
    * 5 中间继承       __proto__这个属性在低版本IE中是不可以使用的
    *    子类的的原型上__proto__k属性本来就应该是指向Object
    *
    *
    *
    *    6  Object.xxx   Object.prototype.xxx  不兼容
    *
    * */
var reg="zjf14sdf46ds1v54";
    String.prototype.match=function(reg){
        var ary = [];
        var res = reg.exec(this);
        while(res){
            ary.push(res);
            res=reg.exec(this)
        }
        return ary
    };
    beg=/\d+?/g;
console.log(reg.match(beg));
</script>
</body>
</html>