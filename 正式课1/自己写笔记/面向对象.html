
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式</title>
</head>
<body>

<script>
    /*
  * 单例模式就是一个对象=>命名空间=>nameSpace
  *
  * 单例模式的作用
  *
  * 就是把描述同一个事物的方法或者属性放在同一个对象里，防止多人同事编辑同一个文件的命名冲突
  *
  * ps  单例模式属性和属之间的方法通过this就可以了
    * */
    //utils    工具



    /*
    * 工厂模式 工厂模式解决的就是批量生产的问题，由于单例模式每次还需要创建一个对象，然后对象中还需要增加属性和方法，那么工厂模式就是每次云慈宁宫之后自动给我创建一个对象
    * ps 工厂模式其实就是一个函数
    * */



    /*
    * 构造函数模式=>类
    *     内置类 ：Array String Nunber Boolean Object RegExp Date...
    *     构造类:function FE （）{}
    *     PS ：是类还是函数在定义的时候我们根本就不知道，只有在执行的时候才能够区分，如果是使用nuw的方式去执行的，那么就是当做一个类，如果是直接FE（）的方式执行的。那么就是一个普通函数
    *     实例：就是具体到这个类其中一个的，比如：每个人就是人类的一个实例
    *    对象：万物皆对象   即使是使用new的方式  那么类里的代码也是和普通函数一样执行
    *    ps：使用实例的创建方式，会默认返回一个对象。普通函数执行需要写return；
    *    ps：在构造函数中，如果return一个引用数据类型，会默认破坏默认返回的实例返回动作，return一个基本数据类型没有影响
    *    ps ：构造中的私有变量和实例没有关系，只有this才会影响实例
    * */
    //front engineer   前端工程师    FE




    /*
    * 4 原型模式 => 就是为了解决把每个实力相同作用的私有方法，抽象出来一个公有方法，让实例天生自带这个方法
    *
    *    1  任何一个函数，只要声明结束就会天生自带（天生自带）一个属性叫prototype(原型)，这个属性的值仍然是一个对象数据类型的
    *    2  函数的原型（Human.prototype）也天生自带两个属性，一个数constructor,值是这个函数（类）本身。
    *          Human.prototype.constructor===Human   真
    *
    *    3任何一个实例都天生自带一个属性叫做__proto__,这个属性的值就是自己所属类的原型   person1.__proto__===human.prototype,每个实例也都是通过__proto__属性都能查找到所属类的原型，那么这个原型相对于每个实例来说是一个公共空间，在这个公共空间添加的方法都是公有方法。
    *    ps  添加公有方法直接添加到类的原型上就可以
    *    4 任何一个引用数据类型都是Object的一个实例
    *    5
    *
    *
    *
    *
    *
    *     * */
</script>
</body>
</html>